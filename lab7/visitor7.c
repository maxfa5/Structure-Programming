/*
          ПРИМЕР
                Задан список посетителей поликлиники. Для каждого указано:
    - ФИО (полностью),
                - номер полиса ОМС (12 цифр),
    - дата рождения (число, месяц, год),
                - диагноз (одним словом, без пробелов),
    - первичный или повторный прием.
                Реализовать:
    - сортировку по фамилии,
    - сортировку по дате рождения,
    - поиск несовершеннолетних пациентов.
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/*
                ШАГ 1 - описание структуры
*/

/* Дата представлена в виде: день, месяц, год.
   Удобно использовать структуру для даты */
struct Date {
  int d, m, y;
};

/* Структура пациента:
   - все строки - это массивы символов, важно правильно определить их длину!
     (максимальное количество символов + нуль-терминатор)
         - номер полиса ОМС - 12 цифр. Типа int недостаточно, поэтому можно
     использовать либо строку (но надо будет проверять, что в ней только цифры),
     либо очень длинное целое long long (но этот тип может не поддерживаться),
     либо double и использовать только его целую часть
         - первичный/повторный прием - логическое значение, поэтому int */
struct Visitor {
  char familia[20];
  char imya[15];
  char otch[15];
  double oms;
  struct Date birthday;
  char reason[40]; /* диагноз */
  int secondary;   /* первичный/повторный прием */
};

/*
                ШАГ 2 - раелизуем функции ввода и вывода
*/

/* Для "подструктур" можно сделать свои функции для удобства.
   Вывод даты в обычном формате (через точку) */
void print_date(const struct Date *p) { printf("%d.%d.%d", p->d, p->m, p->y); }

/* Вывод информации о посетителе */
void print(const struct Visitor *p) {
  printf("FIO:\t%s %s %s\n", p->familia, p->imya, p->otch);
  printf("OMS #:\t%.0lf\n", p->oms); /* печатать 0 цифр после запятой */
  /* для вывода дня рождения используем функцию вывода даты */
  printf("Birthday:\t");
  print_date(&p->birthday);
  printf("\n");
  /* без этой функции можно сделать как в закоментированной строке ниже */
  /*printf("Birthday:\t%d.%d.%d\n", p->birthday.d, p->birthday.m,
   * p->birthday.y);*/
  printf("Diagnos:\t%s\n", p->reason);
  printf("Povtor:\t%s\n", (p->secondary ? "yes" : "no"));
  /* можно было сделать простейший вывод, как в строке ниже, но это некрасиво */
  /*printf("Povtor:\t%d\n", p->secondary);*/
}

/* Ввод даты - число, месяц, год по отдельности.
   Проверка ввода не выполняется для упрощения примера, НО ОНА ДОЛЖНА БЫТЬ! */
void input_date(struct Date *p) {
  printf("\tday:\t");
  scanf("%d", &p->d);
  printf("\tmonth:\t");
  scanf("%d", &p->m);
  printf("\tyear:\t");
  scanf("%d", &p->y);
}

/* Ввод информации о посетителе - каждое поле вводится по отдельности.
   Проверка ввода не выполняется для упрощения примера, НО ОНА ДОЛЖНА БЫТЬ! */
void input(struct Visitor *p) {
  printf("FIO:\t");
  scanf("%s%s%s", p->familia, p->imya, p->otch);
  printf("OMS #:\t");
  scanf("%lg", &p->oms);
  printf("Birthday:\n");
  input_date(&p->birthday); /* для ввода даты использована функция */
  printf("Diagnos:\t");
  scanf("%s", p->reason);
  printf("Povtor (0 - no, 1 - yes):\t");
  scanf("%d", &p->secondary);
}

/*
                ШАГ 3 - реализуем функции сравнения структур для сортировки
*/

/* Сравнение дат рождения двух посетителей.
   Функция ВОЗВРАЩАЕТ истину, если первый меньше второго по дате рождения
         (первый родился раньше) */
int comp_birthday(const struct Visitor *p1, const struct Visitor *p2) {
  /* возможный вариант реализации - сравнивать годы, если они равны, то затем
           сравниваются месяцы, а если они тоже равны, то сравниваются числа,
           хотя делать это отдельными if - громоздко и неэффективно */
  if (p1->birthday.y < p2->birthday.y)
    return 1;
  if (p1->birthday.y > p2->birthday.y)
    return 0;

  if (p1->birthday.m < p2->birthday.m)
    return 1;
  if (p1->birthday.m > p2->birthday.m)
    return 0;

  if (p1->birthday.d < p2->birthday.d)
    return 1;
  else
    return 0;
  /* гораздо эффективнее и компактнее записать все в одном логическом выражении,
     например,
        return p1->birthday.y < p2->birthday.y || ... || ... ;
     (допилить самостоятельно)   */

  /* обратите внимание: p1 - это УКАЗАТЕЛЬ на структуру, поэтому используем
     косвенный селектор "->" чтобы обратиться к полю birthday, а это поле - это
           ОБЪЕКТ структуры (а не указатель), поэтому используем прямой селектор
     ".", чтобы обратиться к ее полям d, m, y */
}

/* Сравнение пациентов по фамилии
   истина = фамилия первого меньше (по алфавиту), чем второго */
int comp_fio(const struct Visitor *p1, const struct Visitor *p2) {
  return strcmp(p1->familia, p2->familia) < 0;
  /* правильно будет сравнивать фамилии, если они одинаковые, то имена,
     а если и они совпадают, то отчества, но здесь приведена самас простая
     реализация сравнения строк для примера */
}

/*
                ШАГ 4 - проверка свойств для поиска (подходит/не подходит)
*/

/* Клиент - несовершеннолетний.
   Реализация очень упрощена для примера */
int is_child(const struct Visitor *p) { return (2020 - p->birthday.y) < 18; }

/*
                ГЛАВНАЯ ФУНКЦИЯ
                параллельно по шагам проверяем здесь все функции, которые пишем
                Т.Е.: пишем функцию - сразу здесь ее вызываем, чтобы проверить,
   и т.д.
*/

int main() {
  /* ШАГ 1 */
  struct Visitor a, b;

  /* ШАГ 2 */
  /* проверяем функции ввода */
  printf("\nEnter a visitor A info:\n");
  input(&a);
  printf("\nEnter a visitor B info:\n");
  input(&b);
  /* проверяем функции вывода */
  printf("\nVisitor A info:\n");
  print(&a);
  printf("\nVisitor B info:\n");
  print(&b);

  /* ШАГ 3 */
  /* проверяем функции сравнения двух объектов */
  printf("\n*Compare*\n");
  if (comp_fio(&a, &b))
    printf("familia A  <  familia B\n");
  else
    printf("familia A  >=  familia B\n");

  if (comp_birthday(&a, &b))
    printf("birthday A  <  birthday B\n");
  else
    printf("birthday A  >=  birthday B\n");

  /* ШАГ 4 */
  /* проверяем ... */
  printf("\n*Check*\n");
  if (is_child(&a))
    printf("Visitor A is a child\n");
  else
    printf("Visitor A is not a child\n");

  if (is_child(&b))
    printf("Visitor B is a child\n");
  else
    printf("Visitor B is not a child\n");

  /* и все :) */

  system("pause");
  return 0;
}

/*
                В лабораторной работе №8 будут использоваться эти функции,
   например в цикле используется if (comp_fio(&a[i], &a[i+1])) чтобы сравнить 2
   элемента (посетителя) при сортировке, или функции is_child и print чтобы
   определить (не)совершеннолетних и вывести на экран при поиске и т.д.
*/
